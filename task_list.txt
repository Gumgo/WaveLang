- Divorce driver chunk size from processing chunk size
	- Use chunk_size synth global
	- Processing chunk size is always fixed, and defined as an execution graph global in the synth source file
		- Defaults to 0
		- If 0, will use the driver chunk size (which can be variable), but is incompatible with certain effects which require fixed size chunk processing
	- Cases to handle:
		- Processing chunk size 0
			- Processing chunk size set to always match driver chunk size (possibly variable)
		- Processing chunk size nonzero, driver chunk size variable
			- Accumulator with delay
		- Processing chunk size nonzero, driver chunk size fixed
			- Driver chunk size is multiple of processing chunk size
				- Process exactly (driver chunk size) / (processing chunk size) processing chunks per driver update
			- Driver chunk size is not multiple of processing chunk size
				- Accumulator with delay
	- Explanation of "accumulator with delay"
		- Instead of immediately processing a chunk, it is added to an accumulator and delayed by the processing chunk size
		- Once the accumulator fills up to the chunk size it is processed and discarded
		- This avoids situations where we need to fill the driver buffer but don't have enough input samples to process a full (fixed-size) chunk

- Task function simplification
	- Remove explicit inout arguments and instead only support in and out
		- In and out arguments can still share the same buffer unless one of the arguments is marked with wl_unshared
	- Create multi-buffer iterators using variadic templates if possible
		- iterate_buffers(buffer_a, buffer_b, buffer_c, <lambda>)
		- Lambda is provided with SIMD values (or pointers in the case of output buffers) for each buffer being iterated
		- Const buffers are handled automatically
		- How should we handle const output? Maybe a bool for "if all inputs are const, mark all outputs as const and only iterate on the first value"?

- Delay types
	- Delay
		- Takes input, returns delayed output
	- Feedback with decay
		- Signal feeds back on itself but multiplied by a decay factor
		- Special-case of general purpose feedback, but common
	- Feedback (general purpose)
		- Split into two functions:
			- void write_feedback(string identifier, real value)
			- real read_feedback(string identifier)
		- Similar to delay but allows the reads to occur BEFORE the writes
		- Unique identifier is used to associate a read and write
			- Emit error on initialization if a single read is associated with multiple writes, or if a single write is associated with multiple reads
		- During initialization, reads/writes
		- Constraint: decay time must be at least as big as chunk processing size
			- Emit error on initialize if this is not true
	- Variable delay
		- Max delay is specified as a constant, actual delay can be variable
		- Delay is sub-sample accurate

- Latency compensation
	- Each variable should have a latency value associated with it
	- If an operation is performed on variables with mismatched latencies, delay operations are inserted to make them match
		- Applies to all outputs as well
		- Constants also get delayed if they are e.g. being added to a variable with latency (I think)
	- The instrument reports a total latency equal to the latency of the outputs

- Fix sampler
	- Remove branching from fetch_sample by using multiple sinc tables to remove the sample shift operations
	- Improve polyphase filtering implementation

- Switch to Flex/Lemon for lexer/parser

- Plugin system ($PLUGIN)
	- Allow users to register their own native modules and tasks
	- Restrict library ID to anything but the 0-255 range

- Audio input stream ($INPUT)
	- Support input parameters to the main module taken from an audio input source

- MIDI input support ($MIDI)
	- Add support for more channels

- Improve compiler diagnostics ($DIAGNOSTIC)
	- Create a diagnostic class to report messages, warnings, and errors
	- Separate out error reporting from error return values

- Upsampled buffer operations ($UPSAMPLE)
	- Upsampled types:
		- real@2x, real@8x, etc.
		- type@Nx means "upsampled by a factor of N"
		- Constants are compatible with any sampling rate factor
	- Upsampled operations:
		- module_name@2x(...)
		- module_name@Nx(...) executes the module at N times the stream sample rate
			- Expects all inputs and outputs to be upsampled by N as well
	- Upsampling and downsampling functions:
		- module real __native_resample(in real signal, const bool filter_nyquist)
		- Special-case logic: "signal" can have any sampling rate factor and is not affected by @Nx
		- In practice:
			- module real@Nx __native_resample@Nx(in real@Mx signal)
			- N and M are independent
		- When downsampling, if filter_nyquist is true, a filter is applied at the nyquist frequency

- Add debug library ($DEBUG)
	- Add modules to print values on a trigger
	- Add scraper attribute to disable optimization/removal of modules with no contributing outputs (otherwise print would be removed)

- Expand the timing library ($TIMING)
	- Add edge triggers

- Scriptable wavetables
	- Introduce sampler_wavetable(const real[] table) function
		- table argument is a constant array of frequency weights where index i represents base_frequency*2^i
		- Generates band-limited mipmap (currently happens in hardcoded C++)
	- Replace hardcoded samplers with utility script
