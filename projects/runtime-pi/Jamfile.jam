# Runtime-Pi - a stand-alone synth engine for Raspberry Pi

import path ;
import sequence ;
import vs-project-generator ;

# We only support 64-bit builds, even when the rest of the targets are 32-bit
project : requirements <address-model>64 ;

local project-name = runtime-pi ;

local defines = ;

local features = ;

local source-dir = $(TOP)/source ;

local all-files = [ path.glob-tree
	### Source paths:
	$(source-dir)/common
	$(source-dir)/driver
	$(source-dir)/engine
	$(source-dir)/execution_graph
	$(source-dir)/natvis
	$(source-dir)/runtime
	:
	### Search patterns:
	$(GLOB_PATTERNS)
	:
	### Exclude patterns:
	]
	### Registration file: no dependency created here, but it gets pulled into the VS project:
	[ path.make $(source-dir)/native_module_registration_inputs.h ]
	[ path.make $(source-dir)/task_function_registration_inputs.h ]
	;

local include-directories =
	$(source-dir)
	$(PORTAUDIO_DIR)/include
	$(RTMIDI_DIR)
	$(RAPIDXML_DIR) ;

# Configuration-dependent libraries: is there a better way to do this?

alias configuration-dependent-libraries :
	[ path.join $(PORTAUDIO_DIR) lib libportaudio.so ]
	[ path.join $(RTMIDI_DIR) lib librtmidi.so.3.0.0 ] ;

local libraries = configuration-dependent-libraries ;

if $(GENERATE_VS_PROJECTS) = 1
{
	# Don't declare any targets when generating VS project files
	local local-files = [ get-local-source-files $(all-files) ] ;
	vs-project-generator.setup-vs-project-config $(TOP) : $(project-name) : $(defines) : $(features) : $(local-files) : $(include-directories) ;
}
else
{
	# Add include directories to features
	features += <include>$(include-directories) <define>$(defines) <variant>debug:<define>_DEBUG ;

	# This target is dependent on the generated registration file
	# HACK adding this dependency seems to cause the scraper to build using the gcc-arm compiler! Omit it for now - make sure to run the scraper manually when necessary
	#features += <dependency>$(TOP)//registration-file ;

	# Determine the set of source files
	local source-files = [ sequence.filter is-c-or-cpp-file : $(all-files) ] ;

	# Declare obj files for each one
	local obj-targets ;
	for local source-file in $(source-files)
	{
		local obj-target = [ get-obj-file-from-source-file $(project-name) : $(source-file) ] ;
		obj-targets += $(obj-target) ;
		obj $(obj-target) : $(source-file) : $(features) <architecture>arm <toolset>gcc-arm <target-os>linux ;
	}

	# Declare the executable
	exe $(project-name)-executable : $(obj-targets) $(libraries) : $(features) <architecture>arm <toolset>gcc-arm <target-os>linux ;

	# Install to the app directory
	local install-dir = [ get-app-dir ] ;
	install $(project-name)-install : $(project-name)-executable :
		<variant>debug,<address-model>64:<location>$(install-dir)/debug_64_pi
		<variant>release,<address-model>64:<location>$(install-dir)/release_64_pi ;
}
