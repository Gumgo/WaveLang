################################
# Syntax Style Guide
#
# rule my-rule-name ( parameter )
# constant MY_CONSTANT ;
# local my-local ;
################################

path-constant TOP : . ;

project : build-dir $(TOP)/bin ;

rule load-root-module ( module )
{
	import modules ;
	modules.load $(module) : : $(TOP) ;
}

load-root-module vs-project-generator ;

import feature ;
import os ;
import path ;
import regex ;
import toolset ;

# Declare features for scraper
feature.feature scraper : : dependency free ;
toolset.flags scraper COMMAND <scraper> ;

feature.feature native-module-registration-function-name : : free ;
toolset.flags scraper NATIVE_MODULE_REGISTRATION_FUNCTION_NAME <native-module-registration-function-name> ;

feature.feature task-function-registration-function-name : : free ;
toolset.flags scraper TASK_FUNCTION_REGISTRATION_FUNCTION_NAME <task-function-registration-function-name> ;

rule to-bool ( value * )
{
	if $(value)
	{
		return 1 ;
	}
	else
	{
		return 0 ;
	}
}

# Constants accessible to all projects
constant GLOB_PATTERNS : *.c *.cpp *.h *.inl *.natvis ;

# Grab variables set from the command line
constant GENERATE_VS_PROJECTS : [ to-bool [ os.environ GENERATE_VS_PROJECTS ] ] ;

rule get-local-source-files ( source-files * )
{
	local relative-dir = [ path.make $(TOP) ] ;
	local local-source-files ;

	for local source-file in $(source-files)
	{
		local-source-files += [ path.relative-to $(relative-dir) $(source-file) ] ;
	}

	return $(local-source-files) ;
}

rule is-c-or-cpp-file ( file )
{
	return [ regex.match "([.](c|(cpp))$)" : $(file) ] ;
}

rule get-obj-file-from-source-file ( project : source-file )
{
	local local-source-file = [ get-local-source-files $(source-file) ] ;
	local obj-file = $(project)/$(local-source-file) ;
	return $(obj-file) ;
}

rule get-app-dir ( )
{
	return $(TOP)/app ;
}

rule scraper ( target : source : properties * )
{
	local scraper-properties = "-xc++" "-std=c++14" ;

	local scraper-include-directories = $(TOP)/source ;
	for local dir in $(scraper-include-directories)
	{
		local native-dir = [ path.native $(dir) ] ;
		scraper-properties += "\"-I"$(native-dir)"\"" ;
	}

	local scraper-defines = SCRAPER_ENABLED ; # Indicates that we're scraping and that we should process task functions
	scraper-properties += -D$(scraper-defines) ;

	properties on $(target) = $(scraper-properties) ;

	# Re-scrape if the scraper is updated
	DEPENDS $(target) : [ on $(target) return $(COMMAND) ] ;
}

actions scraper bind COMMAND bind NATIVE_MODULE_REGISTRATION_FUNCTION_NAME bind TASK_FUNCTION_REGISTRATION_FUNCTION_NAME
{
	$(COMMAND[1]:E=scraper_not_found) -n $(NATIVE_MODULE_REGISTRATION_FUNCTION_NAME) -t $(TASK_FUNCTION_REGISTRATION_FUNCTION_NAME) -o $(<) $(>) -- $(properties)
}

rule run-scraper ( registration-output : declaration-input : native-module-registration-function-name : task-function-registration-function-name )
{
	make $(registration-output) : $(declaration-input) : @scraper :
		<address-model>64
		<scraper>$(TOP)/projects/scraper//scraper-install
		<native-module-registration-function-name>$(native-module-registration-function-name)
		<task-function-registration-function-name>$(task-function-registration-function-name) ;
}

# Declare global target - generated registration file
# $TODO if we call run-scraper from any other jamfile, COMMAND doesn't get bound. Why is this? Need to fix so that $PLUGIN jamfiles can call this rule
local registration-inputs = $(TOP)/source/registration_inputs.h ;
local registration-file-name = $(TOP)/source/generated/registration_generated.inl ;

run-scraper $(registration-file-name) : $(registration-inputs) : "register_native_modules_generated" : "register_task_functions_generated" ;
alias registration-file : $(registration-file-name) ;