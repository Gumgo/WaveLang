import polyphase_fir_generator

plot_results = False
plot_sample_rate = 44100

resampler_filter_enum_name = "e_resampler_filter"

# Tuples of (name, params)
all_filter_params = []

# $TODO add different quality modes maybe

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 0.5
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("upsample_high_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 0.25
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("downsample_2x_high_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 1.0 / 6.0
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("downsample_3x_high_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 0.125
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("downsample_4x_high_quality", params))

# Generate filters and write them to a file
coefficients_per_line = 16

with open("resampler_filters.inl", "w") as file:
	file.write("// This file was auto-generated by generate_resampler_filters.py. Do not edit.\n\n")

	filters = []
	for name, params in all_filter_params:
		filter = polyphase_fir_generator.build_polyphase_fir(params, plot_results, plot_sample_rate)
		filters.append(filter)

		file.write("static constexpr real32 k_{}_phases[] = {{".format(name))
		coefficient_index = 0
		for phase in filter.phases:
			for coefficient in phase:
				if coefficient_index == 0:
					file.write("\n\t");
				file.write("{:.17e}f, ".format(coefficient))
				coefficient_index = (coefficient_index + 1) % coefficients_per_line
		file.write("\n};\n\n")

	# Make sure the resampler filter enum matches what we're generating here
	file.write(
		"STATIC_ASSERT_MSG(enum_count<{}>() == {}, \"Resampler filter enum length mismatch\");\n".format(
			resampler_filter_enum_name,
			len(filters)))
	for index, (name, params) in enumerate(all_filter_params):
		file.write(
			"STATIC_ASSERT_MSG(enum_index({}::k_{}) == {}, \"Resampler filter enum mismatch\");\n".format(
				resampler_filter_enum_name,
				name,
				index))
	file.write("\n")

	# Write the filter parameter structs
	file.write("static const s_resampler_parameters k_resampler_parameters[] = {\n")
	for (name, params), filter in zip(all_filter_params, filters):
		file.write("\t{\n")
		file.write("\t\t{},\n".format(params.upsample_factor))
		file.write("\t\t{},\n".format(params.taps_per_phase))
		file.write("\t\t{},\n".format(filter.latency))
		file.write("\t\tc_wrapped_array<const real32>::construct(k_{}_phases)\n".format(name))
		file.write("\t},\n")
	file.write("};\n\n");

	# The getter function
	file.write("const s_resampler_parameters &get_resampler_parameters(e_resampler_filter resampler_filter) {\n")
	file.write("\twl_assert(VALID_INDEX(enum_index(resampler_filter), NUMBEROF(k_resampler_parameters)));\n")
	file.write("\treturn k_resampler_parameters[enum_index(resampler_filter)];\n")
	file.write("}\n")
