import polyphase_fir_generator

plot_results = False
plot_sample_rate = 44100

resampler_filter_enum_name = "e_resampler_filter"

# Tuples of (name, params)
all_filter_params = []

# $TODO consider adding more quality options.
# Getting the transition bandwidth small enough is tricky for low sample rates, but it can be wider for higher sample rates which allows for fewer coefficients.

# The low quality filters have an attenuation of -50dB
params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 64
params.cutoff_frequency = 0.5
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 4.5
all_filter_params.append(("upsample_low_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 64
params.cutoff_frequency = 0.25
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 4.5
all_filter_params.append(("downsample_2x_low_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 64
params.cutoff_frequency = 1.0 / 6.0
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 4.5
all_filter_params.append(("downsample_3x_low_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 64
params.cutoff_frequency = 0.125
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 4.5
all_filter_params.append(("downsample_4x_low_quality", params))

# The high quality filters have an attenuation of -144dB
params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 0.5
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("upsample_high_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 0.25
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("downsample_2x_high_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 1.0 / 6.0
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("downsample_3x_high_quality", params))

params = polyphase_fir_generator.FilterParams()
params.upsample_factor = 512
params.taps_per_phase = 256
params.cutoff_frequency = 0.125
params.window_type = polyphase_fir_generator.WindowType.KAISER
params.kaiser_beta = 15.0
all_filter_params.append(("downsample_4x_high_quality", params))

# Generate filters and write them to a file
coefficients_per_line = 16

with open("resampler_parameters.inl", "w") as parameters_file, open("resampler_filters.inl", "w") as filters_file:
	# Build the filters
	filters = []
	for name, params in all_filter_params:
		filter = polyphase_fir_generator.build_polyphase_fir(params, plot_results, plot_sample_rate)
		filters.append(filter)

	# Make sure the resampler filter enum matches what we're generating here
	for file in (parameters_file, filters_file):
		file.write("// This file was auto-generated by generate_resampler_filters.py. Do not edit.\n\n")
		file.write(
			"STATIC_ASSERT_MSG(enum_count<{}>() == {}, \"Resampler filter enum length mismatch\");\n".format(
				resampler_filter_enum_name,
				len(filters)))
		for index, (name, params) in enumerate(all_filter_params):
			file.write(
				"STATIC_ASSERT_MSG(enum_index({}::k_{}) == {}, \"Resampler filter enum mismatch\");\n".format(
					resampler_filter_enum_name,
					name,
					index))
		file.write("\n")

	# Write the filter parameter structs
	parameters_file.write("static const s_resampler_parameters k_resampler_parameters[] = {\n")
	for (name, params), filter in zip(all_filter_params, filters):
		parameters_file.write("\t{\n")
		parameters_file.write("\t\t{},\n".format(params.upsample_factor))
		parameters_file.write("\t\t{},\n".format(params.taps_per_phase))
		parameters_file.write("\t\t{}\n".format(filter.latency))
		parameters_file.write("\t},\n")
	parameters_file.write("};\n\n");

	# The getter function
	parameters_file.write("const s_resampler_parameters &get_resampler_parameters(e_resampler_filter resampler_filter) {\n")
	parameters_file.write("\twl_assert(valid_enum_index(resampler_filter));\n")
	parameters_file.write("\treturn k_resampler_parameters[enum_index(resampler_filter)];\n")
	parameters_file.write("}\n")

	# Write the filters themselves
	for (name, params), filter in zip(all_filter_params, filters):
		filters_file.write("static constexpr real32 k_{}_phases[] = {{".format(name))
		coefficient_index = 0
		for phase in filter.phases:
			for coefficient in phase:
				if coefficient_index == 0:
					filters_file.write("\n\t");
				filters_file.write("{:.17e}f, ".format(coefficient))
				coefficient_index = (coefficient_index + 1) % coefficients_per_line
		filters_file.write("\n};\n\n")

	# Write the filter parameter structs
	filters_file.write("static const c_wrapped_array<const real32> k_resampler_phases[] = {\n")
	for name, params in all_filter_params:
		filters_file.write("\tc_wrapped_array<const real32>::construct(k_{}_phases),\n".format(name))
	filters_file.write("};\n\n");

	# The getter function
	filters_file.write("c_wrapped_array<const real32> get_resampler_phases(e_resampler_filter resampler_filter) {\n")
	filters_file.write("\twl_assert(valid_enum_index(resampler_filter));\n")
	filters_file.write("\treturn k_resampler_phases[enum_index(resampler_filter)];\n")
	filters_file.write("}\n")
