# Scraper - Scrapes the code for script module and task declarations and generates registration code

import os

import build_config
import utils

Import("*")

env = env.Clone()

if str(platform) == "win32":
	llvm_config_dir = build_options.llvm_config_dir
	llvm_config_binary = "\"{}\\llvm-config.exe\"".format(llvm_config_dir).strip()
	llvm_include_dir = os.popen("{} --includedir".format(llvm_config_binary)).read().strip()
	#llvm_lib_dir = os.popen("{} --libdir".format(llvm_config_binary)).read().strip()
	llvm_lib_dir = {
		build_config.Configuration.DEBUG: build_options.llvm_lib_dir_debug,
		build_config.Configuration.DEVELOPMENT: build_options.llvm_lib_dir_debug,
		build_config.Configuration.RELEASE: build_options.llvm_lib_dir_release
	}[configuration]

	# Do these work with MSVC?
	#llvm_cpp_flags = os.popen("{} --cppflags".format(llvm_config_binary)).read().strip().split(" ")
	#llvm_cxx_flags = os.popen("{} --cxxflags".format(llvm_config_binary)).read().strip().split(" ")
	llvm_lib_names = os.popen("{} --libnames".format(llvm_config_binary)).read().strip().split(" ")
else:
	raise SCons.Errors.BuildError("Unsupported platform '{}'".format(platform))

if compiler == "cl":
	# We get linker errors without this
	llvm_lib_names.append("Version.lib")

	# Suppress a warning caused by clang in MathExtras.h
	env.Append(CCFLAGS = ["/wd4146"])

# Add clang libs as well - can we query these?
llvm_lib_names += [
	"clangFrontend",
	"clangSerialization",
	"clangDriver",
	"clangTooling",
	"clangParse",
	"clangSema",
	"clangStaticAnalyzerFrontend",
	"clangStaticAnalyzerCheckers",
	"clangStaticAnalyzerCore",
	"clangAnalysis",
	"clangRewriteFrontend",
	"clangRewrite",
	"clangEdit",
	"clangAST",
	"clangLex",
	"clangBasic"
]

env.Append(CPPPATH = ["#source", llvm_include_dir])

sources = utils.enumerate_files(env, ".", utils.SOURCE_EXTENSIONS)

static_libraries = ["common", "native_module", "task_function"]
env.Append(LIBS = static_libraries + llvm_lib_names, LIBPATH = ["../bin", llvm_lib_dir])

objects = []
for source in sources:
	obj = env.StaticObject(source)
	objects += obj

scraper_program = env.Program("scraper", objects)

scraper_installed = env.Install("../bin", scraper_program)
env.Alias("scraper", scraper_installed)

# Run the scraper
# $TODO since SCons can output multiple targets, we should split up registration_generated.inl into two files, instead
# of using the current hack
scraper_input = "#source/registration_inputs.h"
scraper_output = "#source/generated/registration_generated.inl"
native_module_registration_function_name = "register_native_modules_generated"
task_function_registration_function_name = "register_task_functions_generated"
scraper_flags = [
	"-xc++",
	"-std=c++20",
	"-DSCRAPER_ENABLED",
	"\"-I{}\"".format(env.Dir("#source").abspath)
]

if build_options.simd_support is build_config.SIMDSupport.AVX:
	scraper_flags.append("-mavx")
elif build_options.simd_support is build_config.SIMDSupport.AVX2:
	scraper_flags.append("-mavx2")

scraper_command = "${{SOURCES[0]}} -n {} -t {} -o $TARGET ${{SOURCES[1]}} -- {}".format(
	native_module_registration_function_name,
	task_function_registration_function_name,
	" ".join(scraper_flags))

scraper_output_targets = env.Command([scraper_output], [scraper_program, scraper_input], scraper_command)
env.Alias("scraped_registration", scraper_output_targets)

# Note that including registration_generated.inl creates a dependency on scraped_registration - no explicit dependency
# is necessary.
